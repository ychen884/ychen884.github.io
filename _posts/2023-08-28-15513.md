---
layout: post
title: Computer Systems - Currently Updating...
date: 2023-08-29 11:00:00
description: Computer Science - 213/513
tags: CMU
categories: Study
featured: true
---
## **Blog Chapters**
1. [Chapter 1: Binary, Bits, and Integers](#topic-1)
2. [Chapter 2:](#topic-2)
3. [Chapter 3:](#topic-3)



## **Chapter 1: Binary, Bits, and Integers** <a name="topic-1"></a>
[Back to Blog Chapters](#blog-chapters)


### Binary Representation
- Operations represented by bits
- Simple numbers

### Hexadecimal and Octal
- Writing binary takes too much digits
- Dense representation
- 00 to FF
- 0 to 9; A to F
- C language: prefix using 0x to represent hexdecimal
- Formal convention

# Bits, Bytes, and Integers
- Boolean Algebra
- Operate on Bit Vectors: And, Or, Not, Xor 




```markdown
Examples:

- ~0x41 -> 0xBE
- - 01000001 -> 10111110 -> 0xBE
- ~0x00 -> 0xFF
- 0x69 & 0x55 -> 0x41
- 0x69 | 0x55 -> 0x7D


&, |, ^, ~ in C


    0110 1001
&   0101 0101
------------------
    0100 0001


    0110 1001
|   0101 0101
------------------
    0111 1101
```

- Contrast Bit-level operators: **&&, \|\| and !** in C


```markdown
0 is false, non-zero as true
always return 0 or 1 
Early termination

Example:
!0x41 -> 0x0
0x69||0x55 -> 0x01
p && *p (avoid null pointer access)

```
- Shift Operations


```markdown
Left Shift x << y
Fill with 0's on right
Right Shift x >> y
- Logical shift
Fill with 0's on the left
- Arithmetic shift
Relicate most significant bit on left
- Undefined Behavior
Shift amound < 0 or > word size - 1

- How does compiler decide? 
```


- Integer values

```markdown
What happens if we add 1 to 7 for three bits representation?
- overflow, modulus arithmetic 

- Unisigned and Non-negative Integers
- Negative numbers? First bit as signed bit 
    - 0 represent 0 
    - can 0 equal negative 0? 
    - we want -1 + 1 eq 0
- Trick
    1 is 1
    -1 + 1 = 0
    001 + 111 = 1000 -> zero by overflow
    110 + 010 = 1000 (2+(-2)) = 0
    -2 + 5 =  1011 = 011; just bits!

- Finding -x the easy way
    Flip all the bits, and add 1
    -x = ~x + 1
    (two's complement)

- C does not mandate using two's complement
    But most machines do, and we will assume so

- Numeric Ranges:
    0 ~ 2^w - 1
    -2^w-1 ~ 2^w-1 -1 

- Signed and Unisgned in C
    int tx, ty;
    unsigned ux, uy;
    -1 compared to unisgned 0? 
    negative one is greater! Implicitely cast things to unsigned.
    
    if 2147483648U is converted as signed, converted to negative

- Signed Extension:
    01010 -> 001010
    11010 -> 111010
    - sign extension for signed, zeros added for unsigned

- Truncation:
    Converting to fewer number of bits
    - Just truncating bits, may cause value changes
    11010 -> 1010 (no sign change)
    01010 -> 1010 (sign change)
    
- Unsigned Additon
    Straight forward, add bits with carry, discard overflowed bit
    (can get the bit back, but in default in C it is discarded)

    One overflow

- Two's complement Addition
    Same behavior, if convert to unsigned, add together and then convert back to signed

    two overflows: negative & postive overflows


- To maintain the exact results
    Some arbitrary precision packages

- Power of 2 same as shifting
    let compiler do it

```
[Back to Blog Chapters](#blog-chapters)










<!-- This theme implements a built-in Jekyll feature, the use of Rouge, for syntax highlighting.
It supports more than 100 languages.
This example is in C++.
All you have to do is wrap your code in markdown code tags:

````markdown
```c++
code code code
```
````

```c++
int main(int argc, char const \*argv[])
{
    string myString;

    cout << "input a string: ";
    getline(cin, myString);
    int length = myString.length();

    char charArray = new char * [length];

    charArray = myString;
    for(int i = 0; i < length; ++i){
        cout << charArray[i] << " ";
    }

    return 0;
}
```

For displaying code in a list item, you have to be aware of the indentation, as stated in this [Stackoverflow answer](https://stackoverflow.com/questions/34987908/embed-a-code-block-in-a-list-item-with-proper-indentation-in-kramdown/38090598#38090598). You must indent your code by **(3 * bullet_indent_level)** spaces. This is because kramdown (the markdown engine used by Jekyll) indentation for the code block in lists is determined by the column number of the first non-space character after the list item marker. For example:

```markdown
1. We can put fenced code blocks inside nested bullets, too.
   1. Like this:
      ```c
      printf("Hello, World!");
      ```

   2. The key is to indent your fenced block in the same line as the first character of the line.
```

Which displays:

1. We can put fenced code blocks inside nested bullets, too.
   1. Like this:
      ```c
      printf("Hello, World!");
      ```

   2. The key is to indent your fenced block in the same line as the first character of the line.

By default, it does not display line numbers. If you want to display line numbers for every code block, you can set `kramdown.syntax_highlighter_opts.block.line_numbers` to true in your `_config.yml` file.

If you want to display line numbers for a specific code block, all you have to do is wrap your code in a liquid tag:

{% raw %}
{% highlight c++ linenos %}  <br/> code code code <br/> {% endhighlight %}
{% endraw %}

The keyword `linenos` triggers display of line numbers.
Produces something like this:

{% highlight c++ linenos %}

int main(int argc, char const \*argv[])
{
    string myString;

    cout << "input a string: ";
    getline(cin, myString);
    int length = myString.length();

    char charArray = new char * [length];

    charArray = myString;
    for(int i = 0; i < length; ++i){
        cout << charArray[i] << " ";
    }

    return 0;
}

{% endhighlight %} -->
