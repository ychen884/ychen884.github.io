---
layout: post
title: Distributed Systems Notes - Currently Upating...
date: 2024-01-18 11:00:00
description: Distributed Systems Notes - SCS
tags: CMU
categories: Study
featured: true
---

### Course Evaluation (Final grade: N/A)
I will add my course evaluation at the end of this semester.
### Paper reviews
I will upload my paper reviews here later.

## **Blog Chapters**
1. [Chapter 1: Remote Procedure Call (RPC)](#topic-1)
2. [Chapter 2: ](#topic-2)
3. [Chapter 3: ](#topic-3)
4. [Chapter 4: ](#topic-4)
5. [Chapter 5: ](#topic-5)
6. [Chapter 6: ](#topic-6)
7. [Chapter 7: ](#topic-7)



## ** Chapter 1: Remote Procedure Call (RPC) ** <a name="topic-1"></a>
- Try to fake procedure call to local programming
- Why? bring down programming complexity for distributed systems 
- client-server model, per interface
- two aspects: control flow, invocation syntax
- with network delays (theoretically best at speed of light)

##### limitations of RPC 
1. No address space sharing between client and server, can't sharing pointers(call by reference), can't share global data..
2. Delayed binding in RPC

##### Failure independence
- caller and callee live and die together in local setup
- we can witness failure case but hard to do in local
- failure handling consider visibility of failure
- Security: different domains

##### Typical RPC
- client: makerpc(request_packet, &reply_packet): blocks until reply or failure
- server: getrequest(&request_packet) blocks until receives request, sendresponse(reply_packet)

##### Stub routines
- generated by stub generator
- sit between high level purpose and low level network packing/unpacking send/recv..
###### procedure:
```
-> : local procedure call
--: network communication

        Client                                             Server
App -> Stub -> Transport --Network Com--- Transport -> Stub -> App

App calls Stub
Stub pack/unpack
Transport transmit/receive
Server App do actual work then return
Packing and unpacking is usually not elastic in dev env
Correctness and API design is more important

```
- Marshalling/Unmarshalling, Serialization/De-serialization

##### RPC packet format
1. Network transport header(Ethernet, IP, Transport(TCP/UDP))
2. RPC header
```
RPC Version ID
Opcode (Stub)
Flags
parameters + Len
```

##### Stub with dynamically allocated buffer
- variable to indicate how many bytes in coming
- malloc for new memories


##### Failure independence of clients & servers adds complexity
1. Outsourcing (for example, relying on TCP). TCP guarantees reliable, in-order, unlimited delivery.
```
Pain:
- no preservation of write() boundaries
- data is re-framed in transit
- read may return fewer than number of bytes requested

```
2. The buck has to stop somewhere. Do it yourself.
- Retransmission
- duplicate delivery/execution violates RPC semantics, sequence numbering to eliminate
- based on UDP



##### Timeout values in distributed systems
- statistics -> reasonable
- no matter what, could be too soon

##### What does server do when receiving duplication happens?
- indicates one of these happening: 
1. reply lost
2. reply crossed retransmitted request
3. compute time was excessive
4. client too impatient.
5. ...


##### Knowlege at server is always stale relative to client, and vice versa
- processing time/network transmit time, indifferent to client..
- best for server to do is retrans
- should preserve reply, not re-compute, because computation can be substantial
- *my question: what if replies too large? maybe best effort

##### Exactly-once semantics
- How long to keep old replies and sequence numbers
- Rigorous interpretation of "RPC" -> forever
- Server crashes: 
- - saved in non-volatile
- - server response has to be after non-volatile write
- - disk/flash latency per RPC
- - clean undo of partial computations before crash
- exactly-once RPC: 
- - success return -> call exected exactly once
- - call blocks indefinitely, no failure return



##### In practice for RPC package: At-most-once semantics 
```
Avoid indefinite blocking
Declare timeout beyond certain delay: success or not? 
many timeout reasons...
```

##### Slow Servers & Long-Running Calls
```
Solution: 
probes to check server health during long calls
server responds busy while working
essentially a keepalive mechanism
```

##### Orphaned Computations
```
network failure, then server continues, unaware its work is useless
Orphan detection and extermination are difficult - but important
```

##### At-least-once semantics (strongest)
```
Even simpler to implement
Requires operation idempotency
Idempotency is a property of certain operations or API requests, which guarantees that performing the operation multiple times will yield the same result as if it was executed only once.
- for example, read request on locked object or read-only object, current_stock_price(MSFT)
```

###### Choice of semantics (less strong)
1. Achieving exactly-once semantics
```
not provided in any real RPC package
requrie application-level dup elim
built on top of at-most-once RPC
- have to write on disk before replying
```
2. At-most-once (mostly provided by RPC packages)
```
avoids: 
- transactional storage
- non-volatile storageo of replies and sequence #s
- indefinite storage of replies

if crashed, just crash without executing anything
exactly once: have to undo, and do again using instruction in non-vol
```

##### Safety and liveness properties
```
safety: correct functionalty ("At most one entity can execute in a critical section")
- bad things never happen

liveness: characterizes timely execution progress (e.g., "This code is deadlock-free")
- good things will eventually happen
```
- "Exactly-once semantics" -> safety property
- Existence of timeout in at-most-once RPC -> liveness property



##### Placement of Functionality - what are you promising vs deliver
- Protocol layering

##### TCP for RPC
```
TCP timeout -> reconnect
- new connection is unaware of old
- server need to do dup elim
- orphans still possible
- exactly-once RPC no easier with TCP

TCO simplifies at-most-once RPC
TCP hurts since it has independent acks in each direction


User TCP rather UDP:
- not simplify exactly-once imple
- worse performance in best case
- simplify at-most once impl

End-to-end argument:
For a given functionality:
- correctness is expressed relative to two endpoints (safety)
- implementation requires support of those two end points
- support below end points cannot suffice (may improve performance(liveness))

```


##### Critical question: Where to place function in a distributed system?
```
What guarantee promising
end point 
package
simplified implementation
guarantee properties
```

<!-- 
Project 1 Transparant Remote File Operations
writing ur own RPC interfaces


 -->
[Back to Blog Chapters](#blog-chapters)





[Back to Blog Chapters](#blog-chapters)

