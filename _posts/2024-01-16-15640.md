---
layout: post
title: Distributed Systems Notes - Currently Upating...
date: 2024-01-18 11:00:00
description: Distributed Systems Notes - SCS
tags: CMU
categories: Study
featured: true
---

### Course Evaluation (Final grade: N/A)
I will add my course evaluation at the end of this semester.
### Paper reviews
I will upload my paper reviews here later.

## **Blog Chapters**
1. [Chapter 1: Remote Procedure Call (RPC)](#topic-1)
2. [Chapter 2: ](#topic-2)
3. [Chapter 3: ](#topic-3)
4. [Chapter 4: ](#topic-4)
5. [Chapter 5: ](#topic-5)
6. [Chapter 6: ](#topic-6)
7. [Chapter 7: ](#topic-7)



## ** Chapter 1: Remote Procedure Call (RPC) ** <a name="topic-1"></a>
- Try to fake procedure call to local programming
- Why? bring down programming complexity for distributed systems 
- client-server model, per interface
- two aspects: control flow, invocation syntax
- with network delays (theoretically best at speed of light)

##### limitations of RPC 
1. No address space sharing between client and server, can't sharing pointers(call by reference), can't share global data..
2. Delayed binding in RPC

##### Failure independence
- caller and callee live and die together in local setup
- we can witness failure case but hard to do in local
- failure handling consider visibility of failure
- Security: different domains

##### Typical RPC
- client: makerpc(request_packet, &reply_packet): blocks until reply or failure
- server: getrequest(&request_packet) blocks until receives request, sendresponse(reply_packet)

##### Stub routines
- generated by stub generator
- sit between high level purpose and low level network packing/unpacking send/recv..
###### procedure:
```
-> : local procedure call
--: network communication

        Client                                             Server
App -> Stub -> Transport --Network Com--- Transport -> Stub -> App

App calls Stub
Stub pack/unpack
Transport transmit/receive
Server App do actual work then return
Packing and unpacking is usually not elastic in dev env
Correctness and API design is more important

```
- Marshalling/Unmarshalling, Serialization/De-serialization

##### RPC packet format
1. Network transport header(Ethernet, IP, Transport(TCP/UDP))
2. RPC header
```
RPC Version ID
Opcode (Stub)
Flags
parameters + Len
```

##### Stub with dynamically allocated buffer
- variable to indicate how many bytes in coming
- malloc for new memories


##### Failure independence of clients & servers adds complexity
1. Outsourcing (for example, relying on TCP). TCP guarantees reliable, in-order, unlimited delivery.
```
Pain:
- no preservation of write() boundaries
- data is re-framed in transit
- read may return fewer than number of bytes requested

```
2. The buck has to stop somewhere. Do it yourself.
- Retransmission
- duplicate delivery/execution violates RPC semantics, sequence numbering to eliminate
- based on UDP



##### Timeout values in distributed systems
- statistics -> reasonable
- no matter what, could be too soon

##### What does server do when receiving duplication happens?
- indicates one of these happening: 
1. reply lost
2. reply crossed retransmitted request
3. compute time was excessive
4. client too impatient.
5. ...


##### Knowlege at server is always stale relative to client, and vice versa
- processing time/network transmit time, indifferent to client..
- best for server to do is retrans
- should preserve reply, not re-compute, because computation can be substantial
- *my question: what if replies too large? maybe best effort

##### Exactly-once semantics
- How long to keep old replies and sequence numbers


<!-- 
Project 1 Transparant Remote File Operations
writing ur own RPC interfaces


 -->
[Back to Blog Chapters](#blog-chapters)





[Back to Blog Chapters](#blog-chapters)

