---
layout: post
title: Compiler Design Notes - Currently Upating...
date: 2024-01-18 11:00:00
description: Compiler Design Notes - SCS
tags: CMU
categories: Study
featured: true
---


<!-- inductive definition -> inference rules -->
<!-- 

If we prove the top is true, then the bottom form is true.

set of natural numbers:

------- N0
nat(0)

nat(n)
------ N1
nat(n+1)

Set of pair of numbers (x,y) that x <= y, both integers:

------   leq0
leq(0,0)

leq(n,m)
------   leq1
leq(n+1,m+1)

leq(n,m)
------   leq2
leq(n,m+1)


Prove leq(3,4) bing true

leq(0,0)
------
leq(1,1)
------
leq(2,2)
------
leq(3,3)
------   leq2
leq(3,4)


loops can happen but rule designers should make it safe 

Mode:

leq(input, output)
use inference rules to query with an input for an output.
add(n1, n2, n3)
=> n1 + n2 = n3


----------- A1
add(0,n,n)

add(m,n,k)
----------- A2
add(m+1,n,k+1)


what if add(1,1,k)? show k=2?

k = 2
----------- A1
add(0,1,k-1)
----------- A2
add(1,1,k)


use leq rules to create a set:
i, k <= 2
s0: empty set
s1: {(0,0)}
s2: {(1,1),(0,1),(0,0)}
s3: {(2,2),(1,2)...}

 -->

### Course Evaluation (Final grade: N/A)
I will add my course evaluation at the end of this semester.
### Paper reviews
I will upload my paper reviews here later.

## **Blog Chapters**
1. [Chapter 0: Overview of Compiler Design](#topic-1)
2. [Chapter 1: Instruction Selection](#topic-1.1)
3. [Chapter 2: Register Allocation](#topic-2)



## **Chapter 1: Overview of Compiler Design ** <a name="topic-1"></a>



### What makes a good Compiler: metrics
- correctness
- code quality: compiled code runs fast
- efficiency: compilation runs fast
- usability: provides errors/warnings, ...

### Compiler Design
- structure compilers
- applied alg & data structures
- focus on sequential imperative programming languages 
- - not functional, parallel, distributed, OOP...
- code generation and optimization

### Organizing a compiler
#### Front
- split work into different phases
- Lexical analysis -> Token stream
- Parsing -> Abstract syntax tree (mark body of while loop...)
- Sementic analysis (type check, variable initialization)

#### Middle
- IR(intermediate representation) Generation -> Intermediate representations
- Optimize (most challenging)

#### Back
- Instruction selection -> Abstract assembly
- Register allocation -> ASM
Middle and Back has unclear distinctions

[Back to Blog Chapters](#blog-chapters)
## **Chapter 1.1: Instruction Selection ** <a name="topic-1.1"></a>
- Compiler phase
- IR tree -> abstract assembly

Example: 
```
x = 5
return x+x+x*2

->>> Instruction selection
x = 5
temp1 = x + x 
temp2 = x * 2
ret_reg = t1 + t2
ret
```
##### IR tree (more expressions, statements..)
```
Programs p ::= s1,...sn (sequence of statements)
statements s ::= x = e 
                return e

Expressions:
e ::= c int const
      x variable
      e1 ⊕ e2 binary OP (nested)
      ⊕ ::= +1 * 1 / 1 ...
```

##### Abstract Assembly (flat)
```
Program: p ::= i1, ... in (instructions)
Instructions i::= d <- s move
                = d <- s1 ⊕ s2 bin op (sometimes one of the source works as dst)
                = ret return
Operands:
    d,s ::= r register (usually* finite numbers as defined)
          = c int const
          = t temps (variables)
          = x var

```

##### Translations Expr
```
translate(e1 ⊕ e2) = translate(e1); translate(e2);
res1 ⊕ res2?
Better: 
trans(d,e): seq of instructions that stores value of e in destination d. 


e           trans(d,e)
x           d <- x
c           d <- c
e1 ⊕ e2     trans(t1, e1), trans(t2, e2), d<-t1⊕t2, (t1 and t2 are fresh temps)


```

##### Translate statements
```
trans'(s): seq of instru that inlements s
s           trans'(s)
x = e       trans(x,e)
return e    trans(ret,e) return (ret: return register)
```
##### Example
```
IR prog: 
z = (x + 1) * (y * 4)
return z

trans'(p) 
= trans'(z = (x + 1) * (y * 4)), trans'(return z)
= trans(z,(x + 1) * (y * 4)),trans(ret, z), return
= trans(t1,x+1), trans(t2,y * 4), z<- t1 * t2, ret<-z, return
= t3 <- x, t4 <- 1, t1 <- t3 + t4, t5 <- y, t6 <- 4, t2 <- t5 * t6, z <- t1*t2, ret<-z, return
Optimize? directly use x and y instead of moving them to temps

```
##### How to improve
1. Add special cases: for example c ⊕ e2
2. Optimization pass after the first pass of translation (common approach)
3. Different translation

##### Constant propagation
- goal: eliminate move t <- c, p by replacing t with c in p
- But: stop replacing t if it's written again
```
Example: 
t <- 4
x <- t+1   ---> x <- 4+1 
t <- 5
ret <- t   --NO--> ret <- 4
return 
```

##### Copy propagation
- goal: elim move d <- t,p by replacing d with t in p
- But: step replacing if d is written or if t is written
```
t <- 5+1
d <- t 
x <- d+1 ----> x <- t+1
t <- 5+2
ret <- d+1 ----No---> ret <- t + 1
ret
```

##### Static Single Assignment Form 
- every temp is assigned at most once
- don't have to check "writes" but can replace all occurances in propagations
- Conversion to SSA -> user version nums
```
t <- 5+1
d <- t 
x <- d+1 ----> x <- t+1
t <- 5+2
ret <- d+1 ----No---> ret <- t + 1
ret

----->>

t0 <- 5+1
d0 <- t0
x0 <- d0+1
t1 <- 5+2
...
```

[Back to Blog Chapters](#blog-chapters)

## **Chapter 2: Register Allocation ** <a name="topic-2"></a>
- Goal: assign registers and stack locations to temps
##### X86-64: 16 registers, no temps
- stack locations, when keeping track of more variables than registers
##### Strategy
1. Store all temps on the stack (CON: inefficient, still need registers for efficiency)


[Back to Blog Chapters](#blog-chapters)

