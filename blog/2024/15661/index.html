<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Compiler Design Notes - Currently Upating... | Yizhou Chen</title> <meta name="author" content="Yizhou Chen"> <meta name="description" content="Compiler Design Notes - SCS"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://ychen884.github.io/blog/2024/15661/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yizhou </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Compiler Design Notes - Currently Upating...</h1> <p class="post-meta">January 30, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/cmu"> <i class="fas fa-hashtag fa-sm"></i> CMU</a>     ·   <a href="/blog/category/study"> <i class="fas fa-tag fa-sm"></i> Study</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="course-evaluation-final-grade-na">Course Evaluation (Final grade: N/A)</h3> <p>I will add my course evaluation at the end of this semester.</p> <h3 id="paper-reviews">Paper reviews</h3> <p>I will upload my paper reviews here later.</p> <h2 id="blog-chapters"><strong>Blog Chapters</strong></h2> <ol> <li><a href="#topic-1">Chapter 0: Overview of Compiler Design</a></li> <li><a href="#topic-1.1">Chapter 1: Instruction Selection</a></li> <li><a href="#topic-2">Chapter 2: Register Allocation</a></li> <li><a href="#topic-3">Chapter 3: Elaboration(after par/lex..)</a></li> <li><a href="#topic-4">Chapter 4: Static Semantics</a></li> </ol> <h2 id="chapter-1-overview-of-compiler-design--">**Chapter 1: Overview of Compiler Design ** <a name="topic-1"></a> </h2> <h3 id="what-makes-a-good-compiler-metrics">What makes a good Compiler: metrics</h3> <ul> <li>correctness</li> <li>code quality: compiled code runs fast</li> <li>efficiency: compilation runs fast</li> <li>usability: provides errors/warnings, …</li> </ul> <h3 id="compiler-design">Compiler Design</h3> <ul> <li>structure compilers</li> <li>applied alg &amp; data structures</li> <li>focus on sequential imperative programming languages</li> <li> <ul> <li>not functional, parallel, distributed, OOP…</li> </ul> </li> <li>code generation and optimization</li> </ul> <h3 id="organizing-a-compiler">Organizing a compiler</h3> <h4 id="front">Front</h4> <ul> <li>split work into different phases</li> <li>Lexical analysis -&gt; Token stream</li> <li>Parsing -&gt; Abstract syntax tree (mark body of while loop…)</li> <li>Sementic analysis (type check, variable initialization)</li> </ul> <h4 id="middle">Middle</h4> <ul> <li>IR(intermediate representation) Generation -&gt; Intermediate representations</li> <li>Optimize (most challenging)</li> </ul> <h4 id="back">Back</h4> <ul> <li>Instruction selection -&gt; Abstract assembly</li> <li>Register allocation -&gt; ASM Middle and Back has unclear distinctions</li> </ul> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-11-instruction-selection--">**Chapter 1.1: Instruction Selection ** <a name="topic-1.1"></a> </h2> <ul> <li>Compiler phase</li> <li>IR tree -&gt; abstract assembly</li> </ul> <p>Example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 5
return x+x+x*2

-&gt;&gt;&gt; Instruction selection
x = 5
temp1 = x + x 
temp2 = x * 2
ret_reg = t1 + t2
ret
</code></pre></div></div> <h5 id="ir-tree-more-expressions-statements">IR tree (more expressions, statements..)</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Programs p ::= s1,...sn (sequence of statements)
statements s ::= x = e 
                return e

Expressions:
e ::= c int const
      x variable
      e1 ⊕ e2 binary OP (nested)
      ⊕ ::= +1 * 1 / 1 ...
</code></pre></div></div> <h5 id="abstract-assembly-flat">Abstract Assembly (flat)</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Program: p ::= i1, ... in (instructions)
Instructions i::= d &lt;- s move
                = d &lt;- s1 ⊕ s2 bin op (sometimes one of the source works as dst)
                = ret return
Operands:
    d,s ::= r register (usually* finite numbers as defined)
          = c int const
          = t temps (variables)
          = x var

</code></pre></div></div> <h5 id="translations-expr">Translations Expr</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>translate(e1 ⊕ e2) = translate(e1); translate(e2);
res1 ⊕ res2?
Better: 
trans(d,e): seq of instructions that stores value of e in destination d. 


e           trans(d,e)
x           d &lt;- x
c           d &lt;- c
e1 ⊕ e2     trans(t1, e1), trans(t2, e2), d&lt;-t1⊕t2, (t1 and t2 are fresh temps)


</code></pre></div></div> <h5 id="translate-statements">Translate statements</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trans'(s): seq of instru that inlements s
s           trans'(s)
x = e       trans(x,e)
return e    trans(ret,e) return (ret: return register)
</code></pre></div></div> <h5 id="example">Example</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IR prog: 
z = (x + 1) * (y * 4)
return z

trans'(p) 
= trans'(z = (x + 1) * (y * 4)), trans'(return z)
= trans(z,(x + 1) * (y * 4)),trans(ret, z), return
= trans(t1,x+1), trans(t2,y * 4), z&lt;- t1 * t2, ret&lt;-z, return
= t3 &lt;- x, t4 &lt;- 1, t1 &lt;- t3 + t4, t5 &lt;- y, t6 &lt;- 4, t2 &lt;- t5 * t6, z &lt;- t1*t2, ret&lt;-z, return
Optimize? directly use x and y instead of moving them to temps

</code></pre></div></div> <h5 id="how-to-improve">How to improve</h5> <ol> <li>Add special cases: for example c ⊕ e2</li> <li>Optimization pass after the first pass of translation (common approach)</li> <li>Different translation</li> </ol> <h5 id="constant-propagation">Constant propagation</h5> <ul> <li>goal: eliminate move t &lt;- c, p by replacing t with c in p</li> <li>But: stop replacing t if it’s written again <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Example: 
t &lt;- 4
x &lt;- t+1   ---&gt; x &lt;- 4+1 
t &lt;- 5
ret &lt;- t   --NO--&gt; ret &lt;- 4
return 
</code></pre></div> </div> </li> </ul> <h5 id="copy-propagation">Copy propagation</h5> <ul> <li>goal: elim move d &lt;- t,p by replacing d with t in p, But: step replacing if d is written or if t is written</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

t &lt;- 5+1
d &lt;- t 
x &lt;- d+1 ----&gt; x &lt;- t+1
t &lt;- 5+2
ret &lt;- d+1 ---No---&gt; ret &lt;- t + 1
ret
</code></pre></div></div> <h5 id="static-single-assignment-form">Static Single Assignment Form</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- every temp is assigned at most once
- don't have to check "writes" but can replace all occurances in propagations
- Conversion to SSA -&gt; user version nums

t &lt;- 5+1
d &lt;- t 
x &lt;- d+1 ----&gt; x &lt;- t+1
t &lt;- 5+2
ret &lt;- d+1 ----No---&gt; ret &lt;- t + 1
ret

-----&gt;&gt;

t0 &lt;- 5+1
d0 &lt;- t0
x0 &lt;- d0+1
t1 &lt;- 5+2
...
</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-2-register-allocation--">**Chapter 2: Register Allocation ** <a name="topic-2"></a> </h2> <ul> <li>Goal: assign registers and stack locations to temps <h5 id="x86-64-16-registers-no-temps">X86-64: 16 registers, no temps</h5> </li> <li>stack locations, when keeping track of more variables than registers <h5 id="strategy">Strategy</h5> <ol> <li>Store all temps on the stack (CON: inefficient, still need registers for efficiency)</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IR trees(simplified syntax tree) 
--&gt; Instruction selection --&gt; ASM 
--&gt; reg alloc --&gt; ASM
--&gt; x86 asm


Example: 
d &lt;- s1 ⊕ s2
-&gt; reg alloc

rlld &lt;- exd * 4(rsp)
</code></pre></div></div> <h5 id="difficulty-x86-has-15-gen-purpose-registers">Difficulty: x86 has 15 gen purpose registers</h5> <ul> <li>Goal: assign each variable a register</li> <li>may have to use stack locations and clever use of registers for variables</li> </ul> <h5 id="interference">Interference:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x &lt;- 14
y &lt;- 15 
z &lt;- x+y

x &lt;- 14
y &lt;- 15 + x 
ret &lt;- 4+y
ret
if x is not used again, we can use overwrite the register for y
</code></pre></div></div> <h5 id="rigth-ir-for-reg-alloc">Rigth IR for reg alloc?</h5> <h5 id="3-addr-abs-asm">3 addr abs asm</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d &lt;- s1 + s2
d &lt;- s1 / s2
...
</code></pre></div></div> <h5 id="2-addr-abs-asm">2 addr abs asm</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d &lt;- s1
d &lt;- d + s2

d &lt;- s1
d &lt;- d / s2
...

</code></pre></div></div> <h5 id="abstract-x86">abstract x86</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVL S1,d
ADDL S2,d
...
IDIVL
edx:eax / s2 -&gt; eax

MOVL s1, %eax
CLTD (sign-extends eax into edx:eax.)
----
https://stackoverflow.com/questions/17170388/trying-to-understand-the-assembly-instruction-cltd-on-x86
What this means in practice is that edx is filled with the most significant bit of eax (the sign bit). For example, if eax is 0x7F000000 edx would become 0x00000000 after cdq. And if eax is 0x80000000 edx would become 0xFFFFFFFF.
----
IDIVL s2 (edx:eax / s2)
MOVL %eax, d

</code></pre></div></div> <h5 id="reg-alloc-at-3-addr-assem">Reg Alloc at 3-Addr Assem</h5> <ul> <li>leave one register unassigned for later conversion (r11d)</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For example

d &lt;- s1 ⊕ s2
--&gt; 
MOVL s1, %r11d
ADDL s2, %r11d
MOVL %r11d, d
(one of them has to be a register
this will always work, but may not be the optimzied solution)

</code></pre></div></div> <h5 id="reg-alloc-at-2-addr-assem">Reg Alloc at 2-Addr Assem</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For example

d &lt;- s1 + s2
--&gt; 
d &lt;- s1
d &lt;- s2 + d
</code></pre></div></div> <h5 id="how-to-allocate-registers">How to allocate registers?</h5> <ul> <li>Goal: minimize spilling to the stack</li> <li>One method: graph-based, greedy register allocation <ol> <li>Build interference graph ``` Vertices are registers and temps Edges indicate interference (need diff registers)</li> </ol> </li> </ul> <p>Example: t1 – t2 – t3 – eax | | ———–</p> <p>Complexity pf deciding if two temps interfere? Undecidable Why? Reduction to the halting problem x &lt;- 5 y &lt;- 6 complex code (doesn’t use x and y) ret&lt;- x + y return</p> <p>x and y interfere iff complex code terminates</p> <p>Approximate Interference with liveness Liveness: temp t is live at line l if t might be used in the following computation</p> <p>For L1: work backwards temp t is live at l if either of them is valid:</p> <ul> <li>t is read at l</li> <li>t is live at l+1 and not written at line l</li> </ul> <p>Example: x1 &lt;- 1 - x2 &lt;- 1 x1 x3 &lt;- x1 + x2 x2,x1 x4 &lt;- x3 + x2 x3,x2 x5 &lt;- x4 + x3 x3,x4 ret &lt;- x5 x5 return ret ret register</p> <p>life range of t1: 2-3 life range of x2: 3-4 ..</p> <p>t1 &lt;- 1 - t1 &lt;- t1+1 t1 t2 &lt;- t1 t1</p> <p>Construct interf graph: Option 1: Add edge between t1 and t2 if they have overlapping live ranges Option 2: rule 1: For every instruction d &lt;- s1 ⊕ s2 add an edge {d,t} if t is live at the next instruction rule 2: For every move d &lt;- s, add an edge {d,t} that t not in {s,d}, and is live at the next instruction</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>


2. Find coloring with as few colors as possible: Adjacent vertices have different colors
</code></pre></div></div> <p>Given: Graph G = (V,E) and k colors Question: Is there a coloring of V with k colors such that adjacent verticies have different colors Complexity: NP complete for k &gt;= 3</p> <p>What folllows for reg allocation?</p> <p>For a Turing-comp lang It’s undecidable for a prog if there’s an equiv prog that uses k registers (and no tem)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
3. Assign colors to registers and stack locations
</code></pre></div></div> <p>Greedy graph coloring: get a minimal coloring for most programs</p> <p>Assume colors are number 1,2,3…</p> <p>Let N(v) be the nbs of v Input: G(V,E) and ordering V=v1,…,vn Output: Coloring of V: col:V-&gt;{1,..k}</p> <ul> <li>Order matters</li> </ul> <p>x5</p> <p>x4-x3-x2-x1</p> <p>Order 1: x5,x4,x3,x2,x1,ret</p> <p>Order 2: x1,x4,x3,x2,x5,ret</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##### Th: There exists an ordering that produces an optimal coloring
</code></pre></div></div> <p>How to find optimal ordering for chordal graphs?</p> <p>Def: A graph is chordal if every cycle with &gt;= 4 vertices has a chord (edge between two verticies in the cycle that is not in the cycle)</p> <p>Example</p> <p>a - b | | c - d not chordal</p> <p>a - b | / | c - d chordal</p> <p>a - b | x | c - d chordal</p> <p>Intuition: how to get long cycle w/o chord? a over lap with b and c we want d to be not overlapping with a</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#####  Maximum cardinality search
</code></pre></div></div> <p>Input: G, Op: ordering of v for each vertex in V, set wt(v) &lt;- 0</p> <p>For all v ∈ V set wt(v) ← 0 Let W ← V For i ← 1 to n do Let v be a node of maximal weight in W Set vi ← v For all u ∈ W ∩ N(v) set wt(u) ← wt(u) + 1 Set W ← W \ {v}</p> <p>MCS Ordering returns: simplicial elimination ordering if G is chordal Def: v is simplicial in G in N(v) is a clique A simplicial vertex is one whose neighbors form a clique: every two neighbors are adjacent.</p> <p>Def: A simpl elim ordering is an ord v1, … vn st vi is simplicial in Gv1,..vi &lt;- subgraph induced by v1, .. vi (picked)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
##### Theorem 1: The graph is chordal iff it has an simplicial elim ordering

</code></pre></div></div> <p>Proof..</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##### Theorem 2: The greedy coloring alg finds an opt coloring if run with a simpl elim ordering
</code></pre></div></div> <p>Proof: Let k be the number of colors used Observations:</p> <ol> <li> <table> <tbody> <tr> <td>k &lt;= max</td> <td>Ni(vi)</td> <td>+ 1</td> </tr> </tbody> </table> </li> <li>#min colors &gt;= max|Ni(vi)| + 1 ```</li> </ol> <h5 id="--theorem-mcs-returns-a-sompl-elem-ordering-iff-g-is-chordal">-&gt; Theorem: MCS returns a sompl elem ordering iff G is chordal</h5> <ol> <li>Spill: assign remaining colors to stack loc.</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strategies: 
1. number of uses of temps in code, higher use freq get the registers
2. incorp loop nestings
3. highest colors (high color may be used in less time, approx for 1)

</code></pre></div></div> <h4 id="summary">Summary</h4> <ol> <li>Build the interference graph (different ways)</li> <li>Order the vertices with MCS</li> <li>Color with greedy alg</li> <li>Spill if # colors &gt; 13</li> </ol> <h4 id="liveness-analysis--interence-rules">Liveness analysis &amp; interence rules</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>live(l,x) ~ x i live at line l
d != u
l: d &lt;- x ⊕ y live(l+1, u)
--------------------------
      live(l, u)


l: d&lt;- x ⊕ y
------------------
    live(l, x)
    live(l, y)

l: return
------------------
   live(l, ret)


l: x &lt;- c
live(l+1, u), x!=u
-------------------
      live(l,u)

l: x&lt;-y, u!=x
live(l+1, u)
--------------
live(l,u)


l:x&lt;-y
-------
live(l,y)

Using derivation tree to prove if x live at line l

</code></pre></div></div> <h5 id="general-saturation-alg">General Saturation Alg</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Can be used for all predicates
1: start with empty set of facts &lt;- derived predicates
2: pick arg (here: l and t) and a rule with live(l,t) in the conclusion
so that the premises are already facts
3: Repeat until no facts can be derived

Will always stop
</code></pre></div></div> <h5 id="refactoring-liveness-rules">Refactoring liveness rules</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use(l,x)
---------
live(l,x)

*: l' is a possible succesor
live(l'x) succ(l,l') ~def(l,x) 
---------------------------------
      live(l,x)

</code></pre></div></div> <h5 id="need-to-define">Need to define:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use(l,x) ~ x is used at l 
def(l,x) ~ x is def at l
succ(l,l') ~ l' can be a succ of l
</code></pre></div></div> <h5 id="example-1">Example</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l: d &lt;- x ⊕ y
-------------
use(l,x)
use(l,y)
def(l,d)
succ(l,l+1)
</code></pre></div></div> <h5 id="adding-loops-and-conditionals">Adding loops and conditionals:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = l: d &lt;- x ⊕ y
.
.
.
l: goto l' (uncond jump)
l: if(x?c) then lt then lt else lf(cond jump)

New rules:

l: goto l'
-----------
succ(l,l')

l: if(x'c) then lt
else lf
-------------------
succ(l,lt)
succ(l,lf)
use(l,x)


Keep doing iterations until we cannot add more new to the liveness sets
pass 1, pass 2, ...

</code></pre></div></div> <h5 id="interference-graph">Interference graph</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Overlapping live ranges

live(l,x) live(l,y)
-------------------
inter(x,y)

But doesn't work in the presence of that code dead code

Example: 
a &lt;- 1
b &lt;- 2
ret &lt;- a
return
</code></pre></div></div> <ol> <li>Assignment based More sparse ``` l: x &lt;- y ⊕ z live(l+1, u), u!=x ——————————— inter(x,u)</li> </ol> <p>l:x&lt;-y, y!=u live(l+1, u) x!=u —————— inter(x,u)</p> <p>l: x&lt;-c, u!=x live(l+1, u) ————– inter(x,u)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## Chapter 3: Elaboration &lt;a name="topic-3"&gt;&lt;/a&gt;

##### Goal: minimal repr and clear of progr
1. remove syntactic sugar
2. make scope explicit


</code></pre></div></div> <p>Parsing -&gt; Parse tree -&gt; elaboration -&gt; AST(&lt;-Semantic analysis)</p> <p>Example: turn for lops into while loops</p> <p>for(int x=4, x&lt;8128, x++){ y = y+x } ——&gt; elab use declaration(x,int,s) {int x=4; while(x&lt;8128)..} decl(x, int, while(x&lt;8218){..})</p> <p>// Before elaboration for (int x = 4; x &lt; 30; x++) { y = y + x }</p> <p>// After elaboration { int x = 4; while (x &lt; 30) { y = y + x; x += 1 } }</p> <p>abstract syntax</p> <p>declare(x, int,seq(assign(x, 4), while(x &lt; 30, seq(assign(y, y + x), assign(x, x + 1)))))</p> <p>The extra scope is necessary Rather than continuing to perform manipulations on surface syntax, we introduce the BNF of an elaborated abstract syntax</p> <table> <tbody> <tr> <td>Expressions e ::= n</td> <td>x</td> <td>e1 ⊕ e2</td> <td>e1 /o e2</td> <td>f(e1, . . . , en)</td> <td> </td> <td> </td> </tr> <tr> <td> </td> <td>e1 ? e2</td> <td>!e</td> <td>e1 &amp;&amp; e2</td> <td>e1</td> <td> </td> <td>e2</td> </tr> </tbody> </table> <p>/0: potentially effectful operators (such as division or shift, which could raise an exception)</p> <p>⊕ for effect-free operators ? for comparison operators returning a boolean, !, &amp;&amp;, and || for logical negation, conjunction, and disjunction, respectively</p> <p>Statements s ::= declare(x, τ, s) | assign(x, e) | if(e, s1, s2) | while(e, s)| return(e) | nop | seq(s1, s2)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##### Inf rule
</code></pre></div></div> <tp> τ <ident> x <exp1> e1 <exp2> e2 <stmt1> s1 <stmt2> s2 ----------------------------------------------------- for (<tp> <ident> = <exp1>; <exp2>; <stmt1>) <stmt2> declare(x, τ,while(e1,seq(s2, s1))) When we want to translate a for loop that matches the pattern at the bottom, we have to do six things: elaborate the type, elaborate the identifier, elaborate both expressions, elaborate the afterthought, and then elaborate the loop body. x++ -&gt; assign(x, x + 1) make sure any nested for loops in <stmt2>, the body of our for loop, are elaborated ``` ##### WHy IR tree 1. isolate potentially effectful expressions, making their order of execution explicit.simplifies instruction selection and also means that the remaining pure expressions can be optimized much more effectively. 2. make the control flow explicit in the form of conditional or unconditional branches, which is closer to the assembly language target and allows us to apply standard program analyses based on an explicit control flow graph. ``` Pure Expressions p ::= n | x | p1 ⊕ p2 Commands c ::= x ← p | x ← p1 /0 p2 | x ← f(p1, . . . , pn) | if (p1 ? p2) then lt else lf | goto l | l : | return(p) Programs r ::= c1 ; . . . ; cn ``` ##### Translating Expressions ``` tr(e) = &lt;ˇe, eˆ&gt; where eˇ is a sequence of commands r that we need to write down to compute the effects of e and eˆ is a pure expression p that we can use to compute the value of e back up. tr(n) = &lt;·, n&gt; tr(x) = &lt;·, x&gt; tr(e1 ⊕ e2) = &lt;(ˇe1 ; ˇe2), eˆ1 ⊕ eˆ2&gt;? ``` ##### Translating Statements ``` tr(assign(x, e)) = ˇe ; x ← eˆ tr(return(e)) = ˇe ; return(ˆe) tr(nop) = · tr(seq(s1, s2)) = ˇs1 ; ˇs2 tr(if(e, s1, s2)) = ˇe ; if (ˆe != 0) then l1 else l2 ; l1 : ˇs1 ; goto l3 ; l2 : ˇs2 ; l3 : tr(while(e, s)) = l1 : ˇe; if (ˆe != 0) then l2 else l3 ; l2 : ˇs ; goto l1; l3 : ``` ##### Translating Boolean Expressions ``` cp(e1 ? e2, l, l') = ˇe1 ; ˇe2 ; if (ˆe1 ? eˆ2) then l else l' cp(!e, l, l') = cp(e, l', l) cp(e1 &amp;&amp; e2, l, l') = cp(e1, l2, l'); l2 : cp(e2, l, l') cp(e1 || e2, l, l') = left to the reader cp(0, l, l') = goto l' cp(1, l, l') = goto l cp(e, l, l') = ˇe ; if (ˆe != 0) then l else l' tr(if(b, s1, s2)) = cp(b, l1, l2) l1 : tr(s1) ; goto l3 l2 : tr(s2) ; goto l3 l3 : tr(e) = &lt;cp(e, l1, l2); l1 : t ← 1 ; goto l3 l2 : t ← 0 ; goto l3 l3 : , t&gt; ``` ##### Extended basic blocks ``` instead of basic blocks being sequences of commands ending in a jump, they are trees of commands that branch at conditional statements and have unconditional jumps (goto or return) as their leaves ``` ## Chapter 4: Static Semantics <a name="topic-4"></a> ##### abstract syntax ``` After lexing and parsing, a compiler will usually apply elaboration to translate the parse tree to a high-level intermediate form often called abstract syntax. Then we verify that the abstract syntax satisfies the requirements of the static semantics. C0: • Initialization: variables must be defined before they are used. • Proper returns: functions that return a value must have an explicit return statement on every control flow path starting at the beginning of the function. • Types: the program must be well-typed. ``` ##### Abstract Syntax as defined in last chap ##### Def ``` ``` [Back to Blog Chapters](#blog-chapters) </stmt2></stmt2></stmt1></exp2></exp1></ident></tp></stmt2></stmt1></exp2></exp1></ident></tp> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/15640/">Distributed Systems Notes - Currently Upating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/15719/">Advanced Cloud Computing Notes - Currently Upating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/15513/">Computer Systems - Currently Updating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/14741/">Information Security - Currently Updating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/14740/">Fundamentals of Telecommunication Networks - Currently Upating...</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Yizhou Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>