<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Compiler Design Notes - Currently Upating... | Yizhou Chen</title> <meta name="author" content="Yizhou Chen"> <meta name="description" content="Compiler Design Notes - SCS"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://ychen884.github.io/blog/2024/15661/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yizhou </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Compiler Design Notes - Currently Upating...</h1> <p class="post-meta">January 30, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/cmu"> <i class="fas fa-hashtag fa-sm"></i> CMU</a>     ·   <a href="/blog/category/study"> <i class="fas fa-tag fa-sm"></i> Study</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="course-evaluation-final-grade-na">Course Evaluation (Final grade: N/A)</h3> <p>I will add my course evaluation at the end of this semester.</p> <h3 id="paper-reviews">Paper reviews</h3> <p>I will upload my paper reviews here later.</p> <h2 id="blog-chapters"><strong>Blog Chapters</strong></h2> <ol> <li><a href="#topic-1">Chapter 1: Overview of Compiler Design</a></li> <li><a href="#topic-1.1">Chapter 2: Instruction Selection</a></li> <li><a href="#topic-2">Chapter 3: Register Allocation</a></li> <li><a href="#topic-3">Chapter 4: Elaboration(after par/lex..)</a></li> <li><a href="#topic-4">Chapter 5: Static Semantics</a></li> <li><a href="#topic-5">Chapter 6: Grammars</a></li> <li><a href="#topic-6">Chapter 7: Lexical Analysis</a></li> <li><a href="#topic-7">Chapter 8: Function calls</a></li> <li><a href="#topic-8">Chapter 9: SSA</a></li> <li><a href="#topic-9">Chapter 10: Dynamic Semantics</a></li> <li><a href="#topic-10">Chapter 11: Mutable</a></li> <li><a href="#topic-11">Chapter 12: Dataflow Analysis</a></li> </ol> <h2 id="chapter-1-overview-of-compiler-design--">**Chapter 1: Overview of Compiler Design ** <a name="topic-1"></a> </h2> <h3 id="what-makes-a-good-compiler-metrics">What makes a good Compiler: metrics</h3> <ul> <li>correctness</li> <li>code quality: compiled code runs fast</li> <li>efficiency: compilation runs fast</li> <li>usability: provides errors/warnings, …</li> </ul> <h3 id="compiler-design">Compiler Design</h3> <ul> <li>structure compilers</li> <li>applied alg &amp; data structures</li> <li>focus on sequential imperative programming languages</li> <li> <ul> <li>not functional, parallel, distributed, OOP…</li> </ul> </li> <li>code generation and optimization</li> </ul> <h3 id="organizing-a-compiler">Organizing a compiler</h3> <h4 id="front">Front</h4> <ul> <li>split work into different phases</li> <li>Lexical analysis -&gt; Token stream</li> <li>Parsing -&gt; Abstract syntax tree (mark body of while loop…)</li> <li>Sementic analysis (type check, variable initialization)</li> </ul> <h4 id="middle">Middle</h4> <ul> <li>IR(intermediate representation) Generation -&gt; Intermediate representations</li> <li>Optimize (most challenging)</li> </ul> <h4 id="back">Back</h4> <ul> <li>Instruction selection -&gt; Abstract assembly</li> <li>Register allocation -&gt; ASM Middle and Back has unclear distinctions</li> </ul> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-11-instruction-selection--">**Chapter 1.1: Instruction Selection ** <a name="topic-1.1"></a> </h2> <ul> <li>Compiler phase</li> <li>IR tree -&gt; abstract assembly</li> </ul> <p>Example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 5
return x+x+x*2

-&gt;&gt;&gt; Instruction selection
x = 5
temp1 = x + x 
temp2 = x * 2
ret_reg = t1 + t2
ret
</code></pre></div></div> <h5 id="ir-tree-more-expressions-statements">IR tree (more expressions, statements..)</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Programs p ::= s1,...sn (sequence of statements)
statements s ::= x = e 
                return e

Expressions:
e ::= c int const
      x variable
      e1 ⊕ e2 binary OP (nested)
      ⊕ ::= +1 * 1 / 1 ...
</code></pre></div></div> <h5 id="abstract-assembly-flat">Abstract Assembly (flat)</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Program: p ::= i1, ... in (instructions)
Instructions i::= d &lt;- s move
                = d &lt;- s1 ⊕ s2 bin op (sometimes one of the source works as dst)
                = ret return
Operands:
    d,s ::= r register (usually* finite numbers as defined)
          = c int const
          = t temps (variables)
          = x var

</code></pre></div></div> <h5 id="translations-expr">Translations Expr</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>translate(e1 ⊕ e2) = translate(e1); translate(e2);
res1 ⊕ res2?
Better: 
trans(d,e): seq of instructions that stores value of e in destination d. 


e           trans(d,e)
x           d &lt;- x
c           d &lt;- c
e1 ⊕ e2     trans(t1, e1), trans(t2, e2), d&lt;-t1⊕t2, (t1 and t2 are fresh temps)


</code></pre></div></div> <h5 id="translate-statements">Translate statements</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trans'(s): seq of instru that inlements s
s           trans'(s)
x = e       trans(x,e)
return e    trans(ret,e) return (ret: return register)
</code></pre></div></div> <h5 id="example">Example</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IR prog: 
z = (x + 1) * (y * 4)
return z

trans'(p) 
= trans'(z = (x + 1) * (y * 4)), trans'(return z)
= trans(z,(x + 1) * (y * 4)),trans(ret, z), return
= trans(t1,x+1), trans(t2,y * 4), z&lt;- t1 * t2, ret&lt;-z, return
= t3 &lt;- x, t4 &lt;- 1, t1 &lt;- t3 + t4, t5 &lt;- y, t6 &lt;- 4, t2 &lt;- t5 * t6, z &lt;- t1*t2, ret&lt;-z, return
Optimize? directly use x and y instead of moving them to temps

</code></pre></div></div> <h5 id="how-to-improve">How to improve</h5> <ol> <li>Add special cases: for example c ⊕ e2</li> <li>Optimization pass after the first pass of translation (common approach)</li> <li>Different translation</li> </ol> <h5 id="constant-propagation">Constant propagation</h5> <ul> <li>goal: eliminate move t &lt;- c, p by replacing t with c in p</li> <li>But: stop replacing t if it’s written again <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Example: 
t &lt;- 4
x &lt;- t+1   ---&gt; x &lt;- 4+1 
t &lt;- 5
ret &lt;- t   --NO--&gt; ret &lt;- 4
return 
</code></pre></div> </div> </li> </ul> <h5 id="copy-propagation">Copy propagation</h5> <ul> <li>goal: elim move d &lt;- t,p by replacing d with t in p, But: step replacing if d is written or if t is written</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

t &lt;- 5+1
d &lt;- t 
x &lt;- d+1 ----&gt; x &lt;- t+1
t &lt;- 5+2
ret &lt;- d+1 ---No---&gt; ret &lt;- t + 1
ret
</code></pre></div></div> <h5 id="static-single-assignment-form">Static Single Assignment Form</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- every temp is assigned at most once
- don't have to check "writes" but can replace all occurances in propagations
- Conversion to SSA -&gt; user version nums

t &lt;- 5+1
d &lt;- t 
x &lt;- d+1 ----&gt; x &lt;- t+1
t &lt;- 5+2
ret &lt;- d+1 ----No---&gt; ret &lt;- t + 1
ret

-----&gt;&gt;

t0 &lt;- 5+1
d0 &lt;- t0
x0 &lt;- d0+1
t1 &lt;- 5+2
...
</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-2-register-allocation--">**Chapter 2: Register Allocation ** <a name="topic-2"></a> </h2> <ul> <li>Goal: assign registers and stack locations to temps <h5 id="x86-64-16-registers-no-temps">X86-64: 16 registers, no temps</h5> </li> <li>stack locations, when keeping track of more variables than registers <h5 id="strategy">Strategy</h5> <ol> <li>Store all temps on the stack (CON: inefficient, still need registers for efficiency)</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IR trees(simplified syntax tree) 
--&gt; Instruction selection --&gt; ASM 
--&gt; reg alloc --&gt; ASM
--&gt; x86 asm


Example: 
d &lt;- s1 ⊕ s2
-&gt; reg alloc

rlld &lt;- exd * 4(rsp)
</code></pre></div></div> <h5 id="difficulty-x86-has-15-gen-purpose-registers">Difficulty: x86 has 15 gen purpose registers</h5> <ul> <li>Goal: assign each variable a register</li> <li>may have to use stack locations and clever use of registers for variables</li> </ul> <h5 id="interference">Interference:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x &lt;- 14
y &lt;- 15 
z &lt;- x+y

x &lt;- 14
y &lt;- 15 + x 
ret &lt;- 4+y
ret
if x is not used again, we can use overwrite the register for y
</code></pre></div></div> <h5 id="rigth-ir-for-reg-alloc">Rigth IR for reg alloc?</h5> <h5 id="3-addr-abs-asm">3 addr abs asm</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d &lt;- s1 + s2
d &lt;- s1 / s2
...
</code></pre></div></div> <h5 id="2-addr-abs-asm">2 addr abs asm</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d &lt;- s1
d &lt;- d + s2

d &lt;- s1
d &lt;- d / s2
...

</code></pre></div></div> <h5 id="abstract-x86">abstract x86</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVL S1,d
ADDL S2,d
...
IDIVL
edx:eax / s2 -&gt; eax

MOVL s1, %eax
CLTD (sign-extends eax into edx:eax.)
----
https://stackoverflow.com/questions/17170388/trying-to-understand-the-assembly-instruction-cltd-on-x86
What this means in practice is that edx is filled with the most significant bit of eax (the sign bit). For example, if eax is 0x7F000000 edx would become 0x00000000 after cdq. And if eax is 0x80000000 edx would become 0xFFFFFFFF.
----
IDIVL s2 (edx:eax / s2)
MOVL %eax, d

</code></pre></div></div> <h5 id="reg-alloc-at-3-addr-assem">Reg Alloc at 3-Addr Assem</h5> <ul> <li>leave one register unassigned for later conversion (r11d)</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For example

d &lt;- s1 ⊕ s2
--&gt; 
MOVL s1, %r11d
ADDL s2, %r11d
MOVL %r11d, d
(one of them has to be a register
this will always work, but may not be the optimzied solution)

</code></pre></div></div> <h5 id="reg-alloc-at-2-addr-assem">Reg Alloc at 2-Addr Assem</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For example

d &lt;- s1 + s2
--&gt; 
d &lt;- s1
d &lt;- s2 + d
</code></pre></div></div> <h5 id="how-to-allocate-registers">How to allocate registers?</h5> <h6 id="goal-minimize-spilling-to-the-stack">Goal: minimize spilling to the stack</h6> <h6 id="one-method-graph-based-greedy-register-allocation">One method: graph-based, greedy register allocation</h6> <h6 id="build-interference-graph">Build interference graph</h6> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vertices are registers and temps
Edges indicate interference (need diff registers)

Example: 
t1  -- t2 -- t3 -- eax
        |           |
         -----------

Complexity pf deciding if two temps interfere? Undecidable
Why? Reduction to the halting problem
x &lt;- 5
y &lt;- 6
complex code (doesn't use x and y)
ret&lt;- x + y
return

x and y interfere iff complex code terminates


Approximate Interference with liveness
Liveness: temp t is live at line l if t might be used in the 
following computation

For L1: work backwards
temp t is live at l if either of them is valid:
- t is read at l
- t is live at l+1 and not written at line l

Example: 
x1 &lt;- 1            -
x2 &lt;- 1           x1
x3 &lt;- x1 + x2     x2,x1
x4 &lt;- x3 + x2     x3,x2
x5 &lt;- x4 + x3     x3,x4
ret &lt;- x5         x5
return ret        ret register

life range of t1: 2-3
life range of x2: 3-4
..


t1 &lt;- 1     -
t1 &lt;- t1+1  t1
t2 &lt;- t1    t1

Construct interf graph:
Option 1: Add edge between t1 and t2 if they have overlapping live ranges
Option 2: rule 1: For every instruction d &lt;- s1 ⊕ s2
                        add an edge {d,t} if t is  live at the next instruction
          rule 2: For every move d &lt;- s, add an edge {d,t} 
                  that t not in {s,d}, and is live at the next instruction


</code></pre></div></div> <h5 id="find-coloring-with-as-few-colors-as-possible-adjacent-vertices-have-different-colors">Find coloring with as few colors as possible: Adjacent vertices have different colors</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given: Graph G = (V,E) and k colors
Question: Is there a coloring of V with k colors such that adjacent verticies have different colors
Complexity: NP complete for k &gt;= 3 

What folllows for reg allocation? 

For a Turing-comp lang
It's undecidable for a prog if there's an equiv prog that uses k registers (and no tem)

</code></pre></div></div> <h5 id="assign-colors-to-registers-and-stack-locations">Assign colors to registers and stack locations</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Greedy graph coloring: get a minimal coloring for most programs

Assume colors are number 1,2,3...

Let N(v) be the nbs of v
Input: G(V,E) and ordering V=v1,...,vn
Output: Coloring of V: col:V-&gt;{1,..k}

- Order matters

x5 

x4-x3-x2-x1

Order 1: x5,x4,x3,x2,x1,ret

Order 2: x1,x4,x3,x2,x5,ret


</code></pre></div></div> <h5 id="th-there-exists-an-ordering-that-produces-an-optimal-coloring">Th: There exists an ordering that produces an optimal coloring</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>How to find optimal ordering for chordal graphs?

Def: A graph is chordal if every cycle with &gt;= 4 vertices has a chord 
(edge between two verticies in the cycle that is not in the cycle)

Example

a - b
|   |
c - d
not chordal

a - b
| / |
c - d
chordal

a - b
| x |
c - d
chordal


Intuition: how to get long cycle w/o chord?
a over lap with b and c
we want d to be not overlapping with a


</code></pre></div></div> <h5 id="maximum-cardinality-search">Maximum cardinality search</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: G, Op: ordering of v
for each vertex in V, set wt(v) &lt;- 0

For all v ∈ V set wt(v) ← 0
Let W ← V
For i ← 1 to n do
      Let v be a node of maximal weight in W
      Set vi ← v
      For all u ∈ W ∩ N(v) set wt(u) ← wt(u) + 1
      Set W ← W \ {v}


MCS Ordering returns: simplicial elimination ordering if G is chordal
Def: v is simplicial in G in N(v) is a clique
A simplicial vertex is one whose neighbors form a clique: every two neighbors are adjacent. 


Def: A simpl elim ordering is an ord v1, ... vn st vi is simplicial in
Gv1,..vi &lt;- subgraph induced by v1, .. vi (picked)
</code></pre></div></div> <h5 id="theorem-1-the-graph-is-chordal-iff-it-has-an-simplicial-elim-ordering">Theorem 1: The graph is chordal iff it has an simplicial elim ordering</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proof..
</code></pre></div></div> <h5 id="theorem-2-the-greedy-coloring-alg-finds-an-opt-coloring-if-run-with-a-simpl-elim-ordering">Theorem 2: The greedy coloring alg finds an opt coloring if run with a simpl elim ordering</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proof: Let k be the number of colors used
Observations: 
- k &lt;= max|Ni(vi)| + 1
- #min colors &gt;= max|Ni(vi)| + 1
</code></pre></div></div> <h5 id="--theorem-mcs-returns-a-sompl-elem-ordering-iff-g-is-chordal">-&gt; Theorem: MCS returns a sompl elem ordering iff G is chordal</h5> <h5 id="spill-assign-remaining-colors-to-stack-loc">Spill: assign remaining colors to stack loc.</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strategies: 
1. number of uses of temps in code, higher use freq get the registers
2. incorp loop nestings
3. highest colors (high color may be used in less time, approx for 1)

</code></pre></div></div> <h4 id="summary">Summary</h4> <ol> <li>Build the interference graph (different ways)</li> <li>Order the vertices with MCS</li> <li>Color with greedy alg</li> <li>Spill if # colors &gt; 13</li> </ol> <h4 id="liveness-analysis--interence-rules">Liveness analysis &amp; interence rules</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>live(l,x) ~ x i live at line l
d != u
l: d &lt;- x ⊕ y live(l+1, u)
--------------------------
      live(l, u)


l: d&lt;- x ⊕ y
------------------
    live(l, x)
    live(l, y)

l: return
------------------
   live(l, ret)


l: x &lt;- c
live(l+1, u), x!=u
-------------------
      live(l,u)

l: x&lt;-y, u!=x
live(l+1, u)
--------------
live(l,u)


l:x&lt;-y
-------
live(l,y)

Using derivation tree to prove if x live at line l

</code></pre></div></div> <h5 id="general-saturation-alg">General Saturation Alg</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Can be used for all predicates
1: start with empty set of facts &lt;- derived predicates
2: pick arg (here: l and t) and a rule with live(l,t) in the conclusion
so that the premises are already facts
3: Repeat until no facts can be derived

Will always stop
</code></pre></div></div> <h5 id="refactoring-liveness-rules">Refactoring liveness rules</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use(l,x)
---------
live(l,x)

*: l' is a possible succesor
live(l'x) succ(l,l') ~def(l,x) 
---------------------------------
      live(l,x)

</code></pre></div></div> <h5 id="need-to-define">Need to define:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use(l,x) ~ x is used at l 
def(l,x) ~ x is def at l
succ(l,l') ~ l' can be a succ of l
</code></pre></div></div> <h5 id="example-1">Example</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l: d &lt;- x ⊕ y
-------------
use(l,x)
use(l,y)
def(l,d)
succ(l,l+1)
</code></pre></div></div> <h5 id="adding-loops-and-conditionals">Adding loops and conditionals:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = l: d &lt;- x ⊕ y
.
.
.
l: goto l' (uncond jump)
l: if(x?c) then lt then lt else lf(cond jump)

New rules:

l: goto l'
-----------
succ(l,l')

l: if(x'c) then lt
else lf
-------------------
succ(l,lt)
succ(l,lf)
use(l,x)


Keep doing iterations until we cannot add more new to the liveness sets
pass 1, pass 2, ...

</code></pre></div></div> <h5 id="interference-graph">Interference graph</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Overlapping live ranges

live(l,x) live(l,y)
-------------------
inter(x,y)

But doesn't work in the presence of that code dead code

Example: 
a &lt;- 1
b &lt;- 2
ret &lt;- a
return


2. Assignment based
More sparse

l: x &lt;- y ⊕ z live(l+1, u), u!=x
---------------------------------
inter(x,u)

l:x&lt;-y, y!=u
live(l+1, u) x!=u
------------------
inter(x,u)

l: x&lt;-c, u!=x
live(l+1, u)
--------------
inter(x,u)
</code></pre></div></div> <h2 id="chapter-3-elaboration-">Chapter 3: Elaboration <a name="topic-3"></a> </h2> <h5 id="goal-minimal-repr-and-clear-of-progr">Goal: minimal repr and clear of progr</h5> <ul> <li>remove syntactic sugar</li> <li>make scope explicit</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Parsing -&gt; Parse tree -&gt; elaboration -&gt; AST(&lt;-Semantic analysis)

Example: 
turn for lops into while loops

for(int x=4, x&lt;8128, x++){
      y = y+x
}
------&gt; elab
use declaration(x,int,s)
{int x=4; while(x&lt;8128)..}
decl(x, int, while(x&lt;8218){..})

// Before elaboration
for (int x = 4; x &lt; 30; x++) { y = y + x }


// After elaboration
{
int x = 4;
while (x &lt; 30) { y = y + x; x += 1 }
}

abstract syntax

declare(x, int,seq(assign(x, 4),
                  while(x &lt; 30,
                  seq(assign(y, y + x), assign(x, x + 1)))))

The extra scope is necessary
Rather than continuing to perform manipulations on surface syntax, we introduce the BNF of an elaborated abstract syntax


Expressions e ::= n | x | e1 ⊕ e2 | e1 /o e2 | f(e1, . . . , en)
| e1 ? e2 | !e | e1 &amp;&amp; e2 | e1 || e2

/0:  potentially effectful operators (such as division or shift, which could raise an exception)

⊕ for effect-free operators
? for comparison operators returning a boolean, !, &amp;&amp;, and || for logical negation, conjunction, and disjunction, respectively

Statements s ::= 
declare(x, τ, s) | 
assign(x, e) | 
if(e, s1, s2) | 
while(e, s)| 
return(e) | 
nop | 
seq(s1, s2)


</code></pre></div></div> <h5 id="inf-rule">Inf rule</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;tp&gt; τ
&lt;ident&gt; x
&lt;exp1&gt; e1
&lt;exp2&gt; e2
&lt;stmt1&gt; s1
&lt;stmt2&gt; s2
-----------------------------------------------------
for (&lt;tp&gt; &lt;ident&gt; = &lt;exp1&gt;; &lt;exp2&gt;; &lt;stmt1&gt;) &lt;stmt2&gt;
 declare(x, τ,while(e1,seq(s2, s1)))

When we want to translate a for loop that
matches the pattern at the bottom, we have to do six things: 
elaborate the type,
elaborate the identifier, 
elaborate both expressions, 
elaborate the afterthought, and
then elaborate the loop body. 
x++ -&gt; assign(x, x + 1)
make sure any nested for loops in &lt;stmt2&gt;, the body of our for loop, are elaborated

</code></pre></div></div> <h5 id="why-ir-tree">Why IR tree</h5> <h5 id="isolate-potentially-effectful-expressions-making-their-order-of-execution-explicitsimplifies-instruction-selection-and-also-means-that-the-remaining-pure-expressions-can-be-optimized-much-more-effectively">isolate potentially effectful expressions, making their order of execution explicit.simplifies instruction selection and also means that the remaining pure expressions can be optimized much more effectively.</h5> <h5 id="make-the-control-flow-explicit-in-the-form-of-conditional-or-unconditional-branches-which-is-closer-to-the-assembly-language-target-and-allows-us-to-apply-standard-program-analyses-based-on-an-explicit-control-flow-graph">make the control flow explicit in the form of conditional or unconditional branches, which is closer to the assembly language target and allows us to apply standard program analyses based on an explicit control flow graph.</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pure Expressions p ::= n | x | p1 ⊕ p2

Commands c 
::= 
x ← p
| x ← p1 /0 p2
| x ← f(p1, . . . , pn)
| if (p1 ? p2) then lt else lf
| goto l
| l :
| return(p)
Programs r ::= c1 ; . . . ; cn


</code></pre></div></div> <h5 id="translating-expressions">Translating Expressions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tr(e) = &lt;ˇe, eˆ&gt;
where eˇ is a sequence of commands r that we need to write down to compute the
effects of e and eˆ is a pure expression p that we can use to compute the value of e back up. 


tr(n) = &lt;·, n&gt;
tr(x) = &lt;·, x&gt;
tr(e1 ⊕ e2) = &lt;(ˇe1 ; ˇe2), eˆ1 ⊕ eˆ2&gt;?


</code></pre></div></div> <h5 id="translating-statements">Translating Statements</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tr(assign(x, e)) = ˇe ; x ← eˆ
tr(return(e)) = ˇe ; return(ˆe)
tr(nop) = ·
tr(seq(s1, s2)) = ˇs1 ; ˇs2


tr(if(e, s1, s2)) = ˇe ;
if (ˆe != 0) then l1 else l2 ;
l1 : ˇs1 ;
goto l3 ;
l2 : ˇs2 ;
l3 :



tr(while(e, s)) = l1 : ˇe;
if (ˆe != 0) then l2 else l3 ;
l2 : ˇs ; goto l1;
l3 : 
</code></pre></div></div> <h5 id="translating-boolean-expressions">Translating Boolean Expressions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp(e1 ? e2, l, l') = 
ˇe1 ; ˇe2 ;
if (ˆe1 ? eˆ2) then l else l'


cp(!e, l, l') = cp(e, l', l)

cp(e1 &amp;&amp; e2, l, l') = 
cp(e1, l2, l');
l2 : cp(e2, l, l')


cp(e1 || e2, l, l') = left to the reader

cp(0, l, l') = goto l'

cp(1, l, l') = goto l

cp(e, l, l') = 
ˇe ;
if (ˆe != 0) then l else l'


tr(if(b, s1, s2)) = cp(b, l1, l2)
l1 : tr(s1) ; goto l3
l2 : tr(s2) ; goto l3
l3 :


tr(e) = &lt;cp(e, l1, l2);
l1 : t ← 1 ; goto l3
l2 : t ← 0 ; goto l3
l3 :
, t&gt;
</code></pre></div></div> <h5 id="extended-basic-blocks">Extended basic blocks</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> instead of basic blocks being sequences of commands ending
in a jump, they are trees of commands that branch at conditional statements and
have unconditional jumps (goto or return) as their leaves
</code></pre></div></div> <h2 id="chapter-4-static-semantics-">Chapter 4: Static Semantics <a name="topic-4"></a> </h2> <h5 id="abstract-syntax">abstract syntax</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>After lexing and parsing, a compiler will usually apply elaboration to translate the parse tree to a high-level intermediate form often called abstract syntax. Then we verify that the abstract syntax satisfies the requirements of the static semantics.


C0:
• Initialization: variables must be defined before they are used.
• Proper returns: functions that return a value must have an explicit return statement on every control flow path starting at the beginning of the function.
• Types: the program must be well-typed.
</code></pre></div></div> <h5 id="abstract-syntax-as-defined-in-last-chap">Abstract Syntax as defined in last chap</h5> <h5 id="def">Def</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>we would like to raise an error if there is a possibility that
an unitialized variable may be used. 

may-property
use(e1/2, x)
-----------
use(e1 &amp;&amp; e2, x)

use(e1/2, x)
-----------
use(e1 ⊕ e2, x)


must-property
def(s, x) if the execution of statement s will define x.


--------------------
def(assign(x, e), x)



def(s1, x) def(s2, x)
-----------------------
def(if(e, s1, s2), x)

A conditional only defines a variable if is it defined along
 both branches, and a while loop does not define any variable 
 (since the body may never be executed).

def(s1/2, x)
-----------------
def(seq(s1, s2), x)

def(s, x) y != x
---------------------
def(decl(y, τ, s), x)
x is declared at most once on a control-flow
path. 

--------------------
def(return(e), x)
Since a return statement will never
pass the control flow to the next instruction, any subsequent statements are unreachable. It is therefore permissible to claim that all variables currently in scope have been defined. 
</code></pre></div></div> <h6 id="liveness">Liveness</h6> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
We observe that liveness is indeed a may-property, since a variable is live in a conditional if is used in the condition or live in one or more of the branches.


use(e, x)
----------------
live(assign(y, e), x)


use(e, x)
----------------
live(if(e, s1, s2), x)


use(s1, x)
----------------
live(if(e, s1, s2), x)


use(s2, x)
----------------
live(if(e, s1, s2), x)

use(e, x)
----------------
live(while(e, s), x)

live(s, x)
----------------
live(while(e, s), x)

use(e, x)
----------------
live(return(e), x)

no rule for
live(nop, x)

live(x, s) y != x
----------------
live(decl(y, τ, s), x)


live(s1, x)
----------------
live(seq(s1, s2), x)

¬def(s1, x) live(s2, x)
----------------
live(seq(s1, s2), x)

</code></pre></div></div> <h6 id="initialization">Initialization</h6> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>captures the general condition.


should be read from the premises
to the conclusion.
decl(x, τ, s) in p   live(s, x)
------------------------------
error


from the conclusion to the premises


------------------------------
init(nop)


init(s1) init(s2)
------------------------------
init(seq(s1, s2))


init(s) ¬live(s, x)
------------------------------
init(decl(x, τ, s))
</code></pre></div></div> <h5 id="from-judgments-to-functions">From Judgments to Functions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>init : stm → bool
init(nop) = T
init(seq(s1, s2)) = init(s1) ∧ init(s2)
init(decl(x, τ, s)) = init(s) ∧ ¬live(s, x)

live(nop, x) = ⊥
live(seq(s1, s2), x) = live(s1, x) ∨ (¬def(s1, x) ∧ live(s2, x))
live(decl(y, τ, s), x) = y != x ∧ live(x, s)
. . .

...
init(δ, s, δ'): 
assuming all the variables in δ are defined when s is reached, 
no uninitialized variable will be referenced and after its execution 
all the variables in δ' will be defined.

use(δ, e): e will only reference variables defined in δ.

δ |- s ⇒ δ' for init(δ, s, δ').
δ |- e for use(δ, e).

δ ⊢ s1 ⇒ δ1
δ1 ⊢ s2 ⇒ δ2
______________
δ ⊢ seq(s1, s2) ⇒ δ2


δ ⊢ e
_________
δ ⊢ assign(x, e) ⇒ δ ∪ {x}


δ ⊢ e
δ ⊢ s1 ⇒ δ1
δ ⊢ s2 ⇒ δ2
_________________
δ ⊢ if(e, s1, s2) ⇒ δ1 ∩ δ2


δ ⊢ e
δ ⊢ s ⇒ δ'
_________
δ ⊢ while(e, s) ⇒ δ



In particular, declare(x, τ, s) means that the variable x is declared (only) within the statement s.
δ ⊢ s ⇒ δ'
___________
δ ⊢ decl(y, τ, s) ⇒ δ' - {y}


δ ⊢ e
_________
δ ⊢ return(e) ⇒ {x | x in scope}



Typing Judgment for Statements:
The notation Γ ⊢ s : [τ] is a typing judgment for statements,
where Γ is the type environment (context), 
s is a statement, 
and τ is the type. 
This notation signifies that the statement s is well-typed within the 
context Γ and ultimately returns a value of type τ
</code></pre></div></div> <h2 id="chapter-5-grammars--">**Chapter 5: Grammars ** <a name="topic-5"></a> </h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Grammars are a general way to describe languages.
For a given grammar G with start symbol S, a derivation in G is a sequence of rewritings
S → γ1 → · · · → γn = w

A context-free grammar consists of a set of productions of the form X −→ γ, where X is a non-terminal symbol and γ is a potentially mixed sequence of terminal and non-terminal symbols.

While the parse tree removes some ambiguity, it turns out that the example grammar is ambiguous in other, more important, ways.

we can add that string specifically as the new base case
It is important that programming languages be unambiguous in practice. 
 
We can usually rewrite grammars to remove ambiguity, but sometimes we extend the language of context-free grammars to resolve ambiguity. One example is explicitly stating precedence and associativity as a way of resolving ambiguities.

</code></pre></div></div> <h5 id="cyk-parsing">CYK Parsing</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CYK Parsing

The Cocke-Younger-Kasami (CYK) parsing algorithm is a method used to check if a given string can be generated by a context-free grammar (CFG). 
It's especially useful in computational linguistics and computer science for parsing strings. The algorithm requires the CFG to be in Chomsky Normal Form (CNF), 
where production rules are either a non-terminal producing two non-terminals, or a non-terminal producing a terminal.

How CYK Works
Input and Initialization: The algorithm takes a string w of length n and a CFG G in CNF. It initializes a table to store which grammar symbols can generate which substrings of w.

Filling the Table: The algorithm fills a table P, where P[i,j] holds non-terminal symbols that can generate the substring w[i,j]. It starts with the smallest substrings 
(single characters) and combines them to form larger substrings.

For each terminal in w, it adds corresponding non-terminals to P as per the grammar rules.
For each possible split of substrings, it checks if their combination can be generated by any non-terminals as per the grammar rules.
Iterating Over Substrings: It considers all possible substrings of w by their length, from shortest to longest, and checks all possible splits for each substring, looking 
for non-terminals that could generate these parts.

Checking for Acceptance: After filling the table, it checks if the start symbol S is in the top-right cell of the table (P[1,n]). 
If S is present, the string w is accepted by the grammar.

Complexity
The CYK algorithm has a time complexity of O(n^3 * |G|), where n is the length of the string and |G| is the size of the grammar. This complexity comes from considering all substrings, 
all possible splits of each substring, and the grammar size.

Applications
The CYK algorithm is used in syntax checking, natural language processing, and compiler design, where it's important to determine if strings follow specific grammatical rules.

By using dynamic programming, the CYK algorithm efficiently parses strings and determines their grammatical structure under a given CFG.

https://www.youtube.com/watch?v=VTH1k-xiswM
</code></pre></div></div> <h5 id="shift-reduce-parsing">Shift-reduce parsing</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Deductive parsing involves two primary rules originally used in the CYK parsing algorithm, but when we interpret these for shift-reduce parsing, 
we make some modifications.

Rule D1: This is an assertion rule where for any terminal symbol 'a' found in the input string, we can deduce that 'a' derives itself. This is represented as:

a : a


Rule D2: This is a combination rule that states if you have a production in the grammar where a non-terminal X leads to a sequence of symbols (γ1 ... γn), 
and you have established that for substrings w1 through wn of your input string w0, each wi derives γi, 
then you can conclude that the concatenated string w1...wn is derived from X. This rule is written as:

[r] X → γ1 ... γn
w1 : γ1 ... wn : γn
------------------------
w1 ... wn : X


Certainly! Let's put the explanation of the rules for deductive shift-reduce parsing in plain text form:

Deductive parsing involves two primary rules originally used in the CYK parsing algorithm, but when we interpret these for shift-reduce parsing, we make some modifications.

Rule D1: This is an assertion rule where for any terminal symbol 'a' found in the input string, we can deduce that 'a' derives itself. This is represented as:


a : a
Rule D2: This is a combination rule that states if you have a production in the grammar where a non-terminal X leads to a sequence of symbols (γ1 ... γn), 
and you have established that for substrings w1 through wn of your input string w0, each wi derives γi, 
then you can conclude that the concatenated string w1...wn is derived from X. This rule is written as:


[r] X → γ1 ... γn
w1 : γ1 ... wn : γn
------------------------
w1 ... wn : X

When we adapt these rules for shift-reduce parsing, we modify the form of the facts used:

Instead of w : γ, where γ is a sequence of terminals and non-terminals, we look to conclude facts of the form w : β, 
where β is a possibly empty series of terminals and non-terminals.

We then have two operations: shift and reduce, focusing on the rightmost elements of w or β. The rules are:

Start Rule:
This is the base case for parsing, where you start with an empty string deriving an empty string:
ε : ε

Shift Rule:
If you have a fact w : β and 'a' is a terminal symbol next in the input string, you can append 'a' to both w and β:
w : β
w a : β a


Reduce Rule:
If there's a production where X leads to α and you have a string w followed by α in β, you can reduce this by recognizing α as a unit derived from X:

[r] X → α
w : β α
------------
w : β X

The reduce rule is the key to recognizing higher-level structures. Each time you apply it, you replace a sequence of symbols 
(which matches the right-hand side of a production rule) with the non-terminal symbol from the left-hand side of that production rule.

If a grammar is unambiguous, this means
that, as we apply a series of rules to try to derive w : S from ε : ε, there is at most one rule we can apply that will lead us to success.

If we can successfully predict what the next step should be at every point, then we can implement this proof search with a stack 
holding the terminals and nonterminals (on the left) and a queue or array index tracking the unprocessed tokens (on the right).

What would we need to know how to always make the right decision for the grammar above?



We will begin constructing a parse table, where the columns
correspond to the next unshifted token and the rows correspond to patterns that we match against the stack β.
</code></pre></div></div> <h5 id="parse-table">Parse Table</h5> <h5 id="conflicts">Conflicts</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cases where we can make different decisions and still successfully parse the string are called conflicts.

Example:
we have decided to resolve the conflicts by giving a precedence to the operators and declaring both of them to be left-associative

It is also possible to have reduce/reduce conflicts

For many parser generators, the default behavior of a shift/reduce conflict is to shift, and for a reduce/reduce conflict to apply the textually first production in the grammar.
</code></pre></div></div> <h5 id="lr1-and-more">LR(1) and more?</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
The set of languages that we can parse with shift-reduce parsers that have lookahead 1 is called LR(1). But even though a language may be 
describable with an LR(1) grammar, it’s not necessarily the case that every grammar for an LR(1) language can be parsed with a shift-reduce parser. 


Even though the grammar is unambiguous, to parse it correctly, we’d need arbitrary lookahead – we’d need to look over an arbitrary 
number of b tokens to find whether they were followed by a c or a d.
</code></pre></div></div> <h2 id="chapter-6-lexical-analysis--">**Chapter 6: Lexical Analysis ** <a name="topic-6"></a> </h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>turn a raw byte or character input stream coming from the source file into a token stream by chopping the input into pieces and skipping over irrelevant details.

classify input tokens into types like INTEGER or IDENTIFIER or WHILE-keyword or OPENINGBRACKET...

Lexers are specified by regular expressions. Classically, however, they are implemented by finite automata.


deterministic finite automaton (DFA). At every state and every input there is at most one edge enabling a transition.


But in general, finite automata can be nondeterministic finite automata (NFA). That is, for the same input, one path may lead to
an accepting state while another attempt fails.


</code></pre></div></div> <h5 id="regular-expressions---nondeterministic-finite-automata">Regular Expressions -&gt; Nondeterministic Finite Automata</h5> <h5 id="nondeterministic-finite-automata---deterministic-finite-automata">Nondeterministic Finite Automata -&gt; Deterministic Finite Automata</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> instead of a single state, we now consider the set of states in which we could be.


Another operation that is often done by lexer generator tools is to minimize the resulting DFA by merging states and reducing the number of states and transitions in the automaton.

Lexical analysis reduces the complexity of subsequent syntactical analysis by first dividing the raw input stream up into a shorter sequence of tokens, 
each classified by its type (INT, IDENTIFIER, REAL, IF, ...). 
The lexer also filters out irrelevant whitespace and comments from the input stream so that the parser does not have to deal with that anymore. 
The steps for generating a lexer are


1. Specify the token types to be recognized from the input stream by a sequence of regular expressions

2. Bear in mind that the longest possible match rule applies and the first production that matches longest takes precedence.

3. Lexical analysis is implemented by DFA.

4. Convert the regular expressions into NFAs (or directly into DFAs using derivatives).

5. Join them into a master NFA that chooses between the NFAs for each regular expression by a spontaneous ε-transition

6. Determinize the NFA into a DFA

7. Optional: minimize the DFA for space

8. Implement the DFA for a recognizer. Respect the longest possible match rule by storing the last accepted token and 
backtracking the input to this one if the DFA run cannot otherwise complete.

</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-8-function-calls--">**Chapter 8: Function Calls ** <a name="topic-7"></a> </h2> <h5 id="ir">IR</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>two lower-level forms of intermediate representation for function calls. 
1. d ← f(s1, . . . , sn)
2. call f

</code></pre></div></div> <h5 id="calling-conventions">calling conventions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Parameters
first six arguments are passed in registers, the remaining arguments
are passed on the stack
all arguments take 8 bytes of space on the stack, even if the type of
argument would indicate that only 4 bytes need to be passed

callee, should set up its stack frame, reserving space for local variables, spilled temps that could not be assigned to registers, 
and arguments passed to functions it calls in turn

It is recommended to calculate the total space needed statically and then decrementing the stack pointer %rsp by the appropriate amount only one time within the function

%rsp should be aligned 0 mod 16 before another function is called,
and may be assumed to be aligned 8 mod 16 on function entry.


Return
The result is returned in a specific return register %rax.





...
n + 16(%rsp) argument 8
n + 8(%rsp) argument 7
n + (%rsp) return address
local variables         Callee
(%rsp) end of frame     Callee


</code></pre></div></div> <h5 id="registers-convention">Registers convention</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abstract x86-64 
form Register Usage function Preserved accross calls
res0 %rax return value∗ No
arg1 %rdi argument 1 No
arg2 %rsi argument 2 No
arg3 %rdx argument 3 No
arg4 %rcx argument 4 No
arg5 %r8 argument 5 No
arg6 %r9 argument 6 No
ler 7 %r10 caller-saved No
ler 8 %r11 caller-saved No

lee9 %rbx callee-saved Yes
lee10 %rbp callee-saved∗ Yes
lee11 %r12 callee-saved Yes
lee12 %r13 callee-saved Yes
lee13 %r14 callee-saved Yes
lee14 %r15 callee-saved Yes
%rsp stack pointer Yes


</code></pre></div></div> <h5 id="typical-calling-sequence">Typical Calling Sequence</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d ← f(s1, s2, s3):

arg3 ← s3
arg2 ← s2
arg1 ← s1
call f
d ← res0


l : call f
caller-save(r)
---------------- J'8
def(l, r)

caller-save(r) is true of register r among %rax, %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, and %r11.

Now if a temp t is live after a function call, we have to add an infererence edge connecting t with any of the fixed registers 


Callee-saved Registers
%rbx, %rbp, %r12, %r13, %r14 and %r15
The standard approach is to save those that are needed onto the stack in the function prologue and restore them from the stack in the function epilogue, just before returning.
**: saving and restoring them all is safe, but may be overkill
for small functions

If we need more than the available number of caller-saved registers, we assign callee-save registers before we resort to spilling,
but make sure the save them at the beginning of a function and restore them at the end. 


f :
t1 ← lee9
t2 ← lee10
· · ·
function body
· · ·
lee10 ← t2
lee9 ← t1
ret


</code></pre></div></div> <h5 id="liveness-about-calling-convention">Liveness about calling convention</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. During a call, res0, arg1-6 and ler7, ler8 are defined.
2. For each line l and each temp t defined at l, we create an edge between t and any variable live in the successor.



All precolored registers implicitly interfere with each other, so we don’t include that in the interference graph.


</code></pre></div></div> <h2 id="chapter-9-ssa--">**Chapter 9: SSA ** <a name="topic-8"></a> </h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>relabel variables in the code so that each variable is defined
only once in the program text. If the program has this form, called static single assignment (SSA),


then we can perform constant propagation immediately
There are other program analyses and optimizations for which it is convenient to have this property..



</code></pre></div></div> <h5 id="basic-blocks">Basic blocks</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int dist(int x, int y) {
x = x * x;
y = y * y;
return isqrt(x+y);
}

dist(x0,y0):
x1 &lt;- x0 * x0
y1 &lt;- y0 * y0
t0 &lt;- x1 + y1
t1 &lt;- isqrt(t0)
return t1



</code></pre></div></div> <h5 id="loops">Loops</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int pow(int b, int e)
//@requires e &gt;= 0;
{
int r = 1;
while (e &gt; 0)
//@loop_invariant e &gt;= 0;
// r*b^e remains invariant
{
r = r * b;
e = e - 1;
}
return r;
}

pow(b0,e0):
      r0 &lt;- 1
      goto loop(b0,e0,r0)
loop(b1,e1,r1):
      if (e1 &gt; 0)
            then body(b1,e1,r1)
            else done(b1,e1,r1)
body(b2,e2,r2):
      r3 &lt;- r2 * b2
      e3 &lt;- e2 - 1
      goto loop(b2,e3,r3)
done(b3,e4,r4):
      return r4

</code></pre></div></div> <h5 id="minimize-ssa-form">Minimize SSA Form</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>φ Function form to minimized form.
It’s quite simple: repeatedly remove φ-functions of the form
ti = φ(tx1, tx2, . . . txk)


pow(b0,e0):
r0 &lt;- 1
      goto loop
loop:
      b1 &lt;- phi(b0,b2)
      e1 &lt;- phi(e0,e3)
      r1 &lt;- phi(r0,r3)
      if (e1 &gt; 0) then body else done
body:
      b2 &lt;- phi(b1)
      e2 &lt;- phi(e1)
      r2 &lt;- phi(r1)
      r3 &lt;- r2 * b2
      e3 &lt;- e2 - 1
      goto loop

done:
      b3 &lt;- phi(b1)
      e4 &lt;- phi(e1)
      r4 &lt;- phi(e1)
      return r4

-------------------------------------------
pow(b0,e0):
      r0 &lt;- 1
      goto loop
loop:
      e1 &lt;- phi(e0,e3)
      r1 &lt;- phi(r0,r3)
      if (e1 &gt; 0) then body else done
body:
      r3 &lt;- r1 * b0
      e3 &lt;- e1 - 1
      goto loop
done:
      return r1


The new form on the right is, of course, no longer in SSA form. Therefore one cannot apply any SSA-based optimization. Conversion out of SSA should therefore be one of the last steps before code emission. 

At this point register allocation, possibly with register coalescing, can do a good job of eliminating redundant moves.



</code></pre></div></div> <h2 id="chapter-10-dynamics--">**Chapter 10: Dynamics ** <a name="topic-9"></a> </h2> <h5 id="denotational-semantics">Denotational Semantics</h5> <ul> <li>Each part of a program is associated with a denotation</li> </ul> <h5 id="axiomatic-semantics">Axiomatic Semantics</h5> <ul> <li>Strongly related to program logic</li> <li>Gives meaning to phrases using logical axioms <h5 id="operational-semantics">Operational Semantics</h5> </li> <li>Related to interpreters and abstract machines</li> <li>Most popular and flexible form of semantics</li> </ul> <h5 id="expressions">Expressions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Many different styles
- Natural semantics (or big-step semantics or evaluation dynamics)
- Structural operational semantics
- Substructural operational semantics
- Abstract machine (or small-step with continuation)

abstract machine:
Very general
Low-level and elaborate

e &gt; K
valuate expression e and pass the result to the K

Binary operations
With effects

Constant and the empty continuation, stop

Boolean, short cutting

Variable: env that maps variables to values
Never changes when evaluating expressions




</code></pre></div></div> <h5 id="executing-statements">Executing Statements</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Don't pass values to the continuation
Usually have effects on the env
</code></pre></div></div> <h5 id="function-calls">Function Calls</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>What needs to happen at a function call?
• Evaluate the arguments in left-to-right order
• Save the environment of the caller to continue the execution after the function call
• Save the continuation of the caller
• Execute the body of the callee in a new environment that maps the
formal parameters to the argument values
• Pass the return value to the environment of the caller

</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-11-mutable--">**Chapter 11: Mutable ** <a name="topic-10"></a> </h2> <h5 id="pointers-and-arrays">Pointers and Arrays</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>• Static semantics of pointers
Extend:
types with pointer types
expressions with alloc, deref, and null ptr
use an indefinite (polymorphic) type any* for synthesis for NULL
We can compare two pointers using p==q if the have the same type


• Dynamic semantics of pointers
value of a type ptr* is an address that stores a value of type
(or a special address 0)
Allocations return fresh (unused) addresses
Dereferencing retrieves a stored value
Need heap that maps addresses to values


• Static semantics of arrays
type[]
expression has: alloc_array(type, e) | e1[e2]
destination: d[e]

• Dynamic semantics of arrays
Array Evaluation: Access

H ; S ; η ⊢ e1[e2] ▷ K
   ⟶ H ; S ; η ⊢ e1 ▷ (_[e2], K)

H ; S ; η ⊢ a ▷ (_[e2], K)
   ⟶ H ; S ; η ⊢ e2 ▷ (a[_], K)
   // Need types.

H ; S ; η ⊢ i ▷ (a[_], K)
   ⟶ H ; S ; η ⊢ H(a + i*τ|τ) ▷ K
   // a ≠ 0, 0 ≤ i &lt; length(a), a : τ[]
   // Need array sizes.

H ; S ; η ⊢ i ▷ (a[_], K)
   ⟶ exception(mem)
   // a = 0 or i &lt; 0 or i ≥ length(a)


Default Values of Array Type
We also need a default value for array types
• We will just use 0 as the default value again
• It represents an array of length 0
• We can never legally access an array element in the default array
• Warning: Arrays can be compared with equality
• Make sure that alloc_array(t,0) returns a fresh address different from 0
• If arrays have address a=0 then you should not access M[a-8]

* We cannot translate d1[e2] += e3 to d1[e2] = d1[e2] + e3
Effects of e2 and d1 would be evaluated twice

</code></pre></div></div> <h5 id="heap">Heap</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H : (N U {next}) -&gt; Val


Memory exceptions -&gt; SIGUSR2
better for debugging

</code></pre></div></div> <h5 id="array-len">Array len</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Alternative 1: Add length at the front, array address points to the start
Alternative 2: Array address points to the first element
Simplifies address arithmetic
Allows to pass pointers to C
</code></pre></div></div> <h5 id="struct">Struct</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Decl:
struct s;

Defn:
struct s {t1 f1; ... tn fn; };


Arrays are represented with pointers (but cannot be dereferenced)
-&gt; they can be compared and stored in registers

Structs are usually also pointers but they can be dereferenced

Structs are large types that do not fit in registers
</code></pre></div></div> <h5 id="c0-restrictions">C0 restrictions</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Local variables, function parameters, and return values must have
small type

Left and right-hand sides of assignments must have small type

Conditional expressions must have small type

Equality and disequality must compare expressions of small type

Expressions used as statements must have small type
</code></pre></div></div> <h5 id="struct-static-semantics-rules">Struct static semantics rules</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Field names occupy their own namespace: allowed to overlap with
variable, function, or type names (but they must be distinct from
keywords)
• The same field names can be used in different struct definitions
• In a given struct definition, all field names must be distinct
• A struct may be defined at most once

Types struct s that have not (yet) been defined may be referenced as
long as their size is irrelevant

Size is relevant for
- alloc(struct s)
- alloc_array(struct s,e)
- definitions of structs if structs are types of fields

• Struct declarations are optional
‣ An occurrence of struct s in a context where its size is irrelevant
serves as an implicit declaration of the type struct s.

Types:
Extend types with struct types

Expr:
Field access

Lval

Define:
Elab

struct s* x = alloc(struct s)
e-&gt;f = (*e).f
must be defined before access

</code></pre></div></div> <h5 id="struct-sizes">Struct sizes</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Struct sizes determined by laying out the fields from left to right
Ints/bools aligned by 4
Pointers aligned by 8
Struct aligned by most restrictive fields


- Need to pick the right instructions (movl vs movq, cmpl vs cmpq)
- Could always use 8 bytes for spilling.
- Maintain size information in IRs!
- It is a good idea to keep temp/registers of different sizes separate
- If you want moves from small to large temps then make conversion
explicit
zeroextend s^32
signextend s^32

</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> <h2 id="chapter-12-dataflow-analysis--">**Chapter 12: Dataflow analysis ** <a name="topic-11"></a> </h2> <ol> <li>Liveness analysis -&gt; interfere?</li> <li>Neededness analysis -&gt; dead code?</li> <li>reaching definitions -&gt; const/copy prop</li> </ol> <h5 id="recap-liveness">Recap liveness</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use(l,x) =&gt; instr at line l uses x 
def(l,x) =&gt; instr at line l defines x
succ(l,l') =&gt; line l' is a successor of l
live(l,x) =&gt; temp x is live at line l

use(l,x)
----------
live(l,x)

propagate backwards
only if not defined in l' 
use(l',u), succ(l,l'), -def(l', u)
----------------------------------
live(l,u)

</code></pre></div></div> <h5 id="memory-instr-in-ir">Memory instr in IR</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M[y] &lt;- x =&gt; store x at addr y
x &lt;- M[y] =&gt; load addr y'


we use the src and dest
l: M[y] &lt;- x
-------------
use(l,x)
use(l,y)
succ(l, l+1)


we define dst as x
l: x &lt;- M[y]
-------------
def(l,x)
use(l,y)
succ(l, l+1)
</code></pre></div></div> <h5 id="dead-code-elimination">Dead code elimination</h5> <h5 id="dead-code-operations-that-dont-influence-the-result-of-progrfunction">Dead code: operations that don’t influence the result of progr/function</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Result of progr
- mem effects
- return val
- errors
- non-terminate ? 
Can exist in either source code
or translated ASM,... 
Usually we run it multiple times 




</code></pre></div></div> <h5 id="example-remove-dead-code-in-code-factorial-using-liveness-info">Example: Remove dead code in code Factorial using liveness info</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l1: p &lt;- 1
l2: p &lt;- p * x
l3: z &lt;- p + 1 ----------- dead
l4: x &lt;- x-1
l5: if(x &gt; 0) then l2 else l6
l6: return p

Liv anal


l1: p &lt;- 1                          x
l2: p &lt;- p * x                      p,x
l3: z &lt;- p + 1                      p,x
l4: x &lt;- x-1                        p,x   
l5: if(x &gt; 0) then l2 else l6       p
l6: return p                        p      

z is not live at l4 --&gt; can replace l3 with nop
- only if op at l3 has no effects
- like memory operations, division

but if we change that line:
because we propagate liveness of z, we can't use this rule to remove though 
z &lt;- z + 1 is dead code
l1: p &lt;- 1                          x,z
l2: p &lt;- p * x                      p,x,z
l3: z &lt;- z + 1                      p,x,z
l4: x &lt;- x-1                        p,x,z
l5: if(x &gt; 0) then l2 else l6       p,x,z
l6: return p                        p


Conclusion: Liveness does not help much in some cases for removing dead codes.
</code></pre></div></div> <h5 id="neededness-analysis">Neededness Analysis</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----Goal: remove ops that----
(a) have no effect and 
(b) don't have a "needed" result

nec(l,x) =&gt; x is necessary at l 

l: x&lt;- y effect ops z
-----------------------
nec(l,y)
nec(l,z)


l: return x
-----------------------
nec(l,x)


l: M[y] &lt;- x
-----------------------
nec(l,y)
nec(l,z)


c0 no need to worry about this:
l: x &lt;- M[y]
-----------------------
nec(l,y)


l: if (x?c) then l' else l"
---------------------------
nec(l,x)


~~~~~~~~~~ Like liveness ~~~~~~~~~~

nec(l,x)
----------
needed(l,x)


needed(l',x), -def(l,x), succ(l,l')
-------------------------------
needed(l,x)



A more complex rule: 
l: x &lt;- y
.
.
l': return x 

needed(l',x), succ(l, l'), def(x, l)
--------------------------------------
needed(l,x)



We would not accidentally end non-termination:
For infinite loop:

f:
l1: goto f
l2: ret 0

</code></pre></div></div> <h5 id="complexity-ovars--lines">Complexity O(#vars * #lines)</h5> <h5 id="look-at-this-problematic-version-again-using-neededness">Look at this problematic version again using neededness:</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>z &lt;- z + 1 is dead code

First pass, we start at l6, propagate
                                    Needed
l0L z &lt;- 1                          
l1: p &lt;- 1                          x,
l2: p &lt;- p * x                      p,x (the added complex rule)
l3: z &lt;- z + 1                      p
l4: x &lt;- x-1                        p
l5: if(x &gt; 0) then l2 else l6       p
l6: return p                        p


Second pass, we start at l5, propagate
                                    Needed
l0L z &lt;- 1                          
l1: p &lt;- 1                          x,
l2: p &lt;- p * x                      p,x (the added complex rule)
l3: z &lt;- z + 1                      p,x
l4: x &lt;- x-1                        p,x
l5: if(x &gt; 0) then l2 else l6       p,x
l6: return p                        p


?? TODO: Maybe merge in one pass? 

</code></pre></div></div> <h5 id="example-for-optimization">Example for optimization</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s =&gt; elem size
a =&gt; addr of array
n =&gt; length of array

Step 1:
l1: i &lt;- 0
l2: if ( 0 &lt;0) then error else l3 -------&gt; const propagation ----&gt; const folding---&gt; jump l3 ----&gt; one more pass ---&gt; (nop)
l3: if ( 0 &gt;=n) then error else l4
l4: t &lt;- 0 * s ----------------------&gt; t &lt;- 0 --------&gt; then maybe t is not needed, so removed
l5: u &lt;- a + t ----------------------&gt; copy propagation, u &lt;- a
l6: x &lt;- M[u]

what if 
l7: i &lt;- i+1
l7: if (i&lt;n) then l2 else l9
l9: return x 

Then problem is this is not in SSA form, that i is defined twice
defs in l1 and l7 each l2
Cannot do constant propagation, so we are not sure i is 0

predicate we want to define: 

reach(l,x,l') 
complexity: O(#line * #line), much larger than O(#var * #line)







</code></pre></div></div> <p><a href="#blog-chapters">Back to Blog Chapters</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/15640/">Distributed Systems Notes - Currently Upating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/15719/">Advanced Cloud Computing Notes - Currently Upating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/15513/">Computer Systems - Currently Updating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/14741/">Information Security - Currently Updating...</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/14740/">Fundamentals of Telecommunication Networks - Currently Upating...</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Yizhou Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>